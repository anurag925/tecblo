# DSA Blog Creation Progress# DSA Blog Creation Progress



## Overview

Create comprehensive blog posts for all DSA topics with code examples and diagrams using Go.date: "2024-11-27"## Overview



## Progress Checklistexcerpt: "Master the powerful knapsack family of DP problems including 0/1 knapsack, unbounded knapsack, partition problems, and target sum variations. Learn to optimize resource allocation efficiently."Create comprehensive blog posts for all DSA topics with code examples and diagrams using Go.



### Phase 1: Fundamental Data Structurescategory: "Data Structures & Algorithms"

- [x] **Arrays & Two Pointers** - Two pointers patterns, sliding window, prefix sum

- [x] **Arrays Advanced** - Dutch flag, Kadane's algorithm, merge intervals, cycle detectiontags: ["Dynamic Programming", "Algorithms", "Go", "Knapsack", "Optimization", "Resource Allocation"]## Progress Checklist

- [x] **String Fundamentals** - Two pointers in strings, sliding window, KMP algorithm

- [x] **String Advanced** - Rolling hash, trie, backtracking in stringsdifficulty: "Intermediate"

- [x] **Hash Maps & Sets** - Frequency counting, uniqueness detection, dictionary operations

readTime: "30 min"### Phase 1: Fundamental Data Structures

### Phase 2: Linear Data Structures

- [x] **Linked Lists** - Fast/slow pointers, reversal, merging, manipulationseries: "dsa-fundamentals"- [x] **Arrays & Two Pointers** - Two pointers patterns, sliding window, prefix sum

- [x] **Stacks & Queues** - Basic patterns, implementations, applications

- [x] **Binary Search** - Standard search, search on answer, rotated arrays, matrix searchseriesOrder: 20- [x] **Arrays Advanced** - Dutch flag, Kadane's algorithm, merge intervals, cycle detection



### Phase 3: Tree Data StructuresnextInSeries: "dp-sequence-patterns"- [x] **String Fundamentals** - Two pointers in strings, sliding window, KMP algorithm

- [x] **Tree Traversal** - DFS (inorder/preorder/postorder), BFS (level order), Morris traversal

- [x] **Tree Properties & LCA** - Diameter, balanced tree, symmetric tree, lowest common ancestorpreviousInSeries: "dp-basic-patterns"- [x] **String Advanced** - Rolling hash, trie, backtracking in strings

- [x] **Tree Paths & Construction** - Path sum patterns, tree construction from traversals

- [x] **BST Operations** - Validate BST, recover BST, Kth smallest, inorder successor---- [x] **Hash Maps & Sets** - Frequency counting, uniqueness detection, dictionary operations



### Phase 4: Graph Algorithms (6/6 COMPLETE!) ‚úÖ

‚úÖ **Graph Traversal (BFS, DFS)** - `/content/posts/dsa/graph-traversal-mastery.md` (COMPLETE)

‚úÖ **Topological Sort & Union Find** - `/content/posts/dsa/topological-sort-union-find.md` (COMPLETE)# Dynamic Programming Knapsack Patterns: Mastering Resource Optimization### Phase 2: Linear Data Structures

‚úÖ **Dijkstra's Algorithm** - `/content/posts/dsa/dijkstra-algorithm.md` (COMPLETE)

‚úÖ **Bellman-Ford Algorithm** - `/content/posts/dsa/bellman-ford-algorithm.md` (COMPLETE)- [x] **Linked Lists** - Fast/slow pointers, reversal, merging, manipulation

‚úÖ **Floyd-Warshall Algorithm** - `/content/posts/dsa/floyd-warshall-algorithm.md` (COMPLETE)

‚úÖ **A* Algorithm** - `/content/posts/dsa/a-star-algorithm.md` (COMPLETE)The knapsack family represents one of the most important and versatile patterns in dynamic programming. These problems deal with optimal resource allocation under constraints and appear frequently in both competitive programming and real-world optimization scenarios.- [x] **Stacks & Queues** - Basic patterns, implementations, applications



### Phase 5: Dynamic Programming & Advanced Algorithms (3/6 Complete)- [x] **Binary Search** - Standard search, search on answer, rotated arrays, matrix search

‚úÖ **DP Fundamentals** - `/content/posts/dsa/dp-fundamentals.md` (COMPLETE)

‚úÖ **DP Basic Patterns** - `/content/posts/dsa/dp-basic-patterns.md` (COMPLETE)## Table of Contents

‚úÖ **DP Knapsack Patterns** - `/content/posts/dsa/dp-knapsack-patterns.md` (COMPLETE)

üéØ **DP Sequence Patterns** - LIS, LCS, edit distance, palindromic subsequences1. [Knapsack Pattern Overview](#knapsack-overview)### Phase 3: Tree Data Structures

üéØ **DP Grid & Path Patterns** - Unique paths, minimum path sum, dungeon game, cherry pickup

üéØ **DP Advanced Patterns** - Stock problems, digit DP, bitmask DP, interval DP, tree DP2. [0/1 Knapsack (Bounded)](#01-knapsack)- [x] **Tree Traversal** - DFS (inorder/preorder/postorder), BFS (level order), Morris traversal



### Phase 6: Algorithmic Paradigms3. [Unbounded Knapsack](#unbounded-knapsack)- [x] **Tree Properties & LCA** - Diameter, balanced tree, symmetric tree, lowest common ancestor

- [ ] **Backtracking Fundamentals** - Subsets, permutations, combinations, constraint satisfaction

- [ ] **Greedy Algorithms** - Interval problems, activity selection, Huffman coding, task scheduling4. [Subset Sum Patterns](#subset-sum-patterns)- [x] **Tree Paths & Construction** - Path sum patterns, tree construction from traversals

- [ ] **Divide and Conquer** - Merge sort, quick sort, counting inversions, closest pair

- [ ] **Sorting Algorithms** - Sorting patterns, linear time sorts, custom comparators5. [Partition Problems](#partition-problems)- [x] **BST Operations** - Validate BST, recover BST, Kth smallest, inorder successor



### Phase 7: Advanced Data Structures6. [Target Sum Variations](#target-sum-variations)

- [ ] **Heap/Priority Queue** - K smallest/largest, merge K sorted lists, sliding window maximum

- [ ] **Advanced Patterns** - Monotonic stack/queue, trie operations, segment tree, fenwick tree7. [Multi-Dimensional Knapsack](#multi-dimensional-knapsack)### Phase 4: Graph Algorithms (6/6 COMPLETE!) ‚úÖ

- [ ] **Math & Bit Manipulation** - Sieve of Eratosthenes, bit tricks, fast exponentiation, computational geometry

- [ ] **System Design with Data Structures** - LRU/LFU cache, randomized data structures, data stream design8. [Optimization Techniques](#optimization-techniques)‚úÖ **Graph Traversal (BFS, DFS)** - `/content/posts/dsa/graph-traversal-mastery.md` (COMPLETE)



## Current Focus9. [Real-World Applications](#real-world-applications)‚úÖ **Topological Sort & Union Find** - `/content/posts/dsa/topological-sort-union-find.md` (COMPLETE)

üéØ **Phase 5: Dynamic Programming** - Building comprehensive coverage of DP patterns

- Recently completed: Knapsack patterns with real-world applications10. [Problem Recognition](#problem-recognition)‚úÖ **Dijkstra's Algorithm** - `/content/posts/dsa/dijkstra-algorithm.md` (COMPLETE)

- Next: Sequence-based DP (LIS, LCS, edit distance)

‚úÖ **Bellman-Ford Algorithm** - `/content/posts/dsa/bellman-ford-algorithm.md` (COMPLETE)

## Completion Statistics

- **Total Phases**: 7## Knapsack Pattern Overview {#knapsack-overview}‚úÖ **Floyd-Warshall Algorithm** - `/content/posts/dsa/floyd-warshall-algorithm.md` (COMPLETE)

- **Completed Phases**: 4 (Phases 1-4)

- **In Progress**: Phase 5 (3/6 complete)‚úÖ **A* Algorithm** - `/content/posts/dsa/a-star-algorithm.md` (COMPLETE)

- **Blog Posts Created**: 30+

- **Estimated Total Posts**: 45-50### Core Knapsack Variants



## Quality Standards### Phase 5: Dynamic Programming & Advanced Algorithms (2/6 Complete)

‚úÖ Complete Go implementations for all algorithms

‚úÖ Mermaid diagrams for visual representation```mermaid‚úÖ **DP Fundamentals** - `/content/posts/dsa/dp-fundamentals.md` (COMPLETE)

‚úÖ Real-world applications and use cases

‚úÖ Time/space complexity analysisgraph TD‚úÖ **DP Basic Patterns** - `/content/posts/dsa/dp-basic-patterns.md` (COMPLETE)

‚úÖ Common pitfalls and optimization techniques

‚úÖ Progressive difficulty with clear explanations    A[Knapsack Problems] --> B[0/1 Knapsack<br/>Each item once]üéØ **DP Knapsack Patterns** - 0/1 knapsack, unbounded knapsack, target sum variations

    A --> C[Unbounded Knapsack<br/>Unlimited items]üéØ **DP Sequence Patterns** - LIS, LCS, edit distance, palindromic subsequences

    A --> D[Multiple Knapsack<br/>Limited quantities]üéØ **DP Grid & Path Patterns** - Unique paths, minimum path sum, dungeon game, cherry pickup

    üéØ **DP Advanced Patterns** - Stock problems, digit DP, bitmask DP, interval DP, tree DP

    B --> E[Subset Sum]

    B --> F[Partition Equal]### Phase 6: Algorithmic Paradigms

    B --> G[Target Sum]- [ ] **Backtracking Fundamentals** - Subsets, permutations, combinations, constraint satisfaction

    - [ ] **Greedy Algorithms** - Interval problems, activity selection, Huffman coding, task scheduling

    C --> H[Coin Change]- [ ] **Divide and Conquer** - Merge sort, quick sort, counting inversions, closest pair

    C --> I[Perfect Squares]- [ ] **Sorting Algorithms** - Sorting patterns, linear time sorts, custom comparators

    C --> J[Combination Sum]

    ### Phase 7: Advanced Data Structures

    D --> K[Bin Packing]- [ ] **Heap/Priority Queue** - K smallest/largest, merge K sorted lists, sliding window maximum

    D --> L[Multi-Constraint]- [ ] **Advanced Patterns** - Monotonic stack/queue, trie operations, segment tree, fenwick tree

    - [ ] **Math & Bit Manipulation** - Sieve of Eratosthenes, bit tricks, fast exponentiation, computational geometry

    style B fill:#e8f5e8- [ ] **System Design with Data Structures** - LRU/LFU cache, randomized data structures, data stream design

    style C fill:#fff3e0

    style D fill:#e3f2fd## Implementation Strategy

```- Each blog post will be 2000-4000 words

- Include practical code examples in Go

### The Knapsack Decision Framework- Add Mermaid diagrams for visual explanations

- Include time/space complexity analysis

Each knapsack problem involves making decisions:- Add practice problems and variations

- **What to include?** (items, coins, numbers)- Include real-world applications and use cases

- **What's the constraint?** (weight, capacity, target sum)

- **What to optimize?** (maximize value, minimize cost, count ways)## Current Task

Working on Phase 4: **Shortest Path Algorithms** - Dijkstra, Bellman-Ford, Floyd-Warshall, A* algorithms for optimal pathfinding.

## 0/1 Knapsack (Bounded) {#01-knapsack}

### Classic 0/1 Knapsack

Each item can be taken at most once.

```go
// Item represents a knapsack item
type Item struct {
    Weight int
    Value  int
}

// Classic 0/1 Knapsack - Maximize value within weight constraint
func knapsack01(items []Item, capacity int) int {
    n := len(items)
    
    // dp[i][w] = max value using first i items with weight <= w
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    for i := 1; i <= n; i++ {
        for w := 0; w <= capacity; w++ {
            // Don't take item i-1
            dp[i][w] = dp[i-1][w]
            
            // Take item i-1 if it fits
            if items[i-1].Weight <= w {
                takeValue := dp[i-1][w-items[i-1].Weight] + items[i-1].Value
                dp[i][w] = max(dp[i][w], takeValue)
            }
        }
    }
    
    return dp[n][capacity]
}

// Space-optimized version using 1D array
func knapsack01Optimized(items []Item, capacity int) int {
    dp := make([]int, capacity+1)
    
    for _, item := range items {
        // Process backwards to avoid using updated values
        for w := capacity; w >= item.Weight; w-- {
            dp[w] = max(dp[w], dp[w-item.Weight]+item.Value)
        }
    }
    
    return dp[capacity]
}

// Track which items are selected
func knapsack01WithItems(items []Item, capacity int) (int, []int) {
    n := len(items)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    // Fill DP table
    for i := 1; i <= n; i++ {
        for w := 0; w <= capacity; w++ {
            dp[i][w] = dp[i-1][w]
            if items[i-1].Weight <= w {
                takeValue := dp[i-1][w-items[i-1].Weight] + items[i-1].Value
                dp[i][w] = max(dp[i][w], takeValue)
            }
        }
    }
    
    // Backtrack to find selected items
    selected := []int{}
    w := capacity
    for i := n; i > 0; i-- {
        if dp[i][w] != dp[i-1][w] {
            selected = append(selected, i-1)  // Item index
            w -= items[i-1].Weight
        }
    }
    
    return dp[n][capacity], selected
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 0/1 Knapsack Variations

```go
// Minimum number of items to achieve target value
func minItemsForValue(items []Item, targetValue int) int {
    dp := make([]int, targetValue+1)
    
    // Initialize with impossible value
    for i := 1; i <= targetValue; i++ {
        dp[i] = len(items) + 1
    }
    
    for _, item := range items {
        for v := targetValue; v >= item.Value; v-- {
            dp[v] = min(dp[v], dp[v-item.Value]+1)
        }
    }
    
    if dp[targetValue] > len(items) {
        return -1  // Impossible
    }
    return dp[targetValue]
}

// Count number of ways to achieve exact weight
func countWaysExactWeight(weights []int, target int) int {
    dp := make([]int, target+1)
    dp[0] = 1  // One way to achieve weight 0
    
    for _, weight := range weights {
        for w := target; w >= weight; w-- {
            dp[w] += dp[w-weight]
        }
    }
    
    return dp[target]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## Unbounded Knapsack {#unbounded-knapsack}

### Classic Unbounded Knapsack

Each item can be taken unlimited times.

```go
// Unbounded Knapsack - Each item can be used multiple times
func knapsackUnbounded(items []Item, capacity int) int {
    dp := make([]int, capacity+1)
    
    for w := 1; w <= capacity; w++ {
        for _, item := range items {
            if item.Weight <= w {
                dp[w] = max(dp[w], dp[w-item.Weight]+item.Value)
            }
        }
    }
    
    return dp[capacity]
}

// Alternative: Process by items (same result, different perspective)
func knapsackUnboundedByItems(items []Item, capacity int) int {
    dp := make([]int, capacity+1)
    
    for _, item := range items {
        for w := item.Weight; w <= capacity; w++ {
            dp[w] = max(dp[w], dp[w-item.Weight]+item.Value)
        }
    }
    
    return dp[capacity]
}

// Count number of ways to fill knapsack exactly
func countWaysUnbounded(weights []int, target int) int {
    dp := make([]int, target+1)
    dp[0] = 1
    
    for _, weight := range weights {
        for w := weight; w <= target; w++ {
            dp[w] += dp[w-weight]
        }
    }
    
    return dp[target]
}

// Minimum items to achieve target (Coin Change pattern)
func minItemsUnbounded(items []Item, targetValue int) int {
    dp := make([]int, targetValue+1)
    
    for i := 1; i <= targetValue; i++ {
        dp[i] = targetValue + 1  // Impossible value
    }
    
    for i := 1; i <= targetValue; i++ {
        for _, item := range items {
            if item.Value <= i {
                dp[i] = min(dp[i], dp[i-item.Value]+1)
            }
        }
    }
    
    if dp[targetValue] > targetValue {
        return -1
    }
    return dp[targetValue]
}
```

## Subset Sum Patterns {#subset-sum-patterns}

### Basic Subset Sum

Can we achieve a target sum using subset of numbers?

```go
// Basic Subset Sum - Can achieve target sum?
func canPartitionSum(nums []int, target int) bool {
    dp := make([]bool, target+1)
    dp[0] = true  // Can always make sum 0
    
    for _, num := range nums {
        // Process backwards to avoid using same element multiple times
        for sum := target; sum >= num; sum-- {
            dp[sum] = dp[sum] || dp[sum-num]
        }
    }
    
    return dp[target]
}

// Count subsets with target sum
func countSubsetsWithSum(nums []int, target int) int {
    dp := make([]int, target+1)
    dp[0] = 1  // One way to make sum 0 (empty subset)
    
    for _, num := range nums {
        for sum := target; sum >= num; sum-- {
            dp[sum] += dp[sum-num]
        }
    }
    
    return dp[target]
}

// Find all possible subset sums
func allPossibleSums(nums []int) []int {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    
    dp := make([]bool, totalSum+1)
    dp[0] = true
    
    for _, num := range nums {
        for sum := totalSum; sum >= num; sum-- {
            dp[sum] = dp[sum] || dp[sum-num]
        }
    }
    
    var possibleSums []int
    for sum, possible := range dp {
        if possible {
            possibleSums = append(possibleSums, sum)
        }
    }
    
    return possibleSums
}
```

### Advanced Subset Sum Variations

```go
// Closest subset sum to target
func closestSubsetSum(nums []int, target int) int {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    
    // Find all possible sums up to totalSum
    dp := make([]bool, totalSum+1)
    dp[0] = true
    
    for _, num := range nums {
        for sum := totalSum; sum >= num; sum-- {
            dp[sum] = dp[sum] || dp[sum-num]
        }
    }
    
    // Find closest sum to target
    minDiff := math.MaxInt32
    closestSum := 0
    
    for sum := 0; sum <= totalSum; sum++ {
        if dp[sum] {
            diff := abs(sum - target)
            if diff < minDiff {
                minDiff = diff
                closestSum = sum
            }
        }
    }
    
    return closestSum
}

// Subset sum with minimum difference
func minSubsetSumDiff(nums []int) int {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    
    // Find all possible sums up to totalSum/2
    target := totalSum / 2
    dp := make([]bool, target+1)
    dp[0] = true
    
    for _, num := range nums {
        for sum := target; sum >= num; sum-- {
            dp[sum] = dp[sum] || dp[sum-num]
        }
    }
    
    // Find largest sum <= totalSum/2
    for sum := target; sum >= 0; sum-- {
        if dp[sum] {
            // One subset has sum 'sum', other has 'totalSum - sum'
            return totalSum - 2*sum
        }
    }
    
    return totalSum
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

## Partition Problems {#partition-problems}

### Equal Partition

```go
// Can partition array into two equal sum subsets?
func canPartition(nums []int) bool {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    
    // If total sum is odd, can't partition equally
    if totalSum%2 != 0 {
        return false
    }
    
    target := totalSum / 2
    return canPartitionSum(nums, target)
}

// Partition into k equal sum subsets
func canPartitionKSubsets(nums []int, k int) bool {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    
    if totalSum%k != 0 {
        return false
    }
    
    target := totalSum / k
    used := make([]bool, len(nums))
    
    return backtrackPartition(nums, used, 0, k, 0, target)
}

func backtrackPartition(nums []int, used []bool, start, k, currentSum, target int) bool {
    if k == 1 {
        return true  // Last subset automatically has correct sum
    }
    
    if currentSum == target {
        // Found one subset, look for remaining k-1 subsets
        return backtrackPartition(nums, used, 0, k-1, 0, target)
    }
    
    for i := start; i < len(nums); i++ {
        if !used[i] && currentSum+nums[i] <= target {
            used[i] = true
            if backtrackPartition(nums, used, i+1, k, currentSum+nums[i], target) {
                return true
            }
            used[i] = false
        }
    }
    
    return false
}
```

### Multi-Way Partition

```go
// Partition into 3 equal sum subsets
func canPartitionThree(nums []int) bool {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    
    if totalSum%3 != 0 {
        return false
    }
    
    target := totalSum / 3
    
    // Use 3D DP: dp[i][sum1][sum2] = can partition first i nums 
    // such that subset1 has sum1 and subset2 has sum2
    memo := make(map[[3]int]bool)
    
    return canPartitionThreeDP(nums, 0, 0, 0, target, memo)
}

func canPartitionThreeDP(nums []int, idx, sum1, sum2, target int, memo map[[3]int]bool) bool {
    if idx == len(nums) {
        return sum1 == target && sum2 == target
    }
    
    key := [3]int{idx, sum1, sum2}
    if result, exists := memo[key]; exists {
        return result
    }
    
    num := nums[idx]
    result := false
    
    // Try putting current number in each of the 3 subsets
    // Subset 1
    if sum1+num <= target {
        result = result || canPartitionThreeDP(nums, idx+1, sum1+num, sum2, target, memo)
    }
    
    // Subset 2
    if sum2+num <= target {
        result = result || canPartitionThreeDP(nums, idx+1, sum1, sum2+num, target, memo)
    }
    
    // Subset 3 (remaining sum)
    totalRemaining := 0
    for i := idx; i < len(nums); i++ {
        totalRemaining += nums[i]
    }
    sum3 := totalRemaining - num
    if sum3 <= target {
        result = result || canPartitionThreeDP(nums, idx+1, sum1, sum2, target, memo)
    }
    
    memo[key] = result
    return result
}
```

## Target Sum Variations {#target-sum-variations}

### Target Sum with +/- Signs

```go
// Assign +/- to each number to reach target sum
func findTargetSumWays(nums []int, target int) int {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    
    // Transform problem: 
    // Let P = sum of positive numbers, N = sum of negative numbers
    // P - N = target, P + N = totalSum
    // Therefore: P = (target + totalSum) / 2
    
    if target > totalSum || target < -totalSum || (target+totalSum)%2 != 0 {
        return 0
    }
    
    positiveSum := (target + totalSum) / 2
    return countSubsetsWithSum(nums, positiveSum)
}

// Target sum with limited operations
func findTargetSumWaysLimited(nums []int, target int, maxOps int) int {
    memo := make(map[[3]int]int)
    return findTargetSumDP(nums, 0, target, maxOps, memo)
}

func findTargetSumDP(nums []int, idx, remaining, opsLeft int, memo map[[3]int]int) int {
    if idx == len(nums) {
        if remaining == 0 && opsLeft >= 0 {
            return 1
        }
        return 0
    }
    
    if opsLeft < 0 {
        return 0
    }
    
    key := [3]int{idx, remaining, opsLeft}
    if result, exists := memo[key]; exists {
        return result
    }
    
    num := nums[idx]
    result := 0
    
    // Use positive sign
    result += findTargetSumDP(nums, idx+1, remaining-num, opsLeft-1, memo)
    
    // Use negative sign  
    result += findTargetSumDP(nums, idx+1, remaining+num, opsLeft-1, memo)
    
    // Skip this number (if operations allow)
    if opsLeft > 0 {
        result += findTargetSumDP(nums, idx+1, remaining, opsLeft, memo)
    }
    
    memo[key] = result
    return result
}
```

### Expression Target

```go
// Add operators (+, -, *) between digits to reach target
func addOperators(num string, target int) []string {
    var result []string
    if len(num) == 0 {
        return result
    }
    
    backtrackExpression(num, target, 0, "", 0, 0, &result)
    return result
}

func backtrackExpression(num string, target int, idx int, expr string, eval, multed int64, result *[]string) {
    if idx == len(num) {
        if eval == int64(target) {
            *result = append(*result, expr)
        }
        return
    }
    
    for i := idx; i < len(num); i++ {
        numStr := num[idx : i+1]
        
        // Skip numbers with leading zeros (except "0" itself)
        if len(numStr) > 1 && numStr[0] == '0' {
            break
        }
        
        numVal, _ := strconv.ParseInt(numStr, 10, 64)
        
        if idx == 0 {
            // First number, no operator needed
            backtrackExpression(num, target, i+1, numStr, numVal, numVal, result)
        } else {
            // Try addition
            backtrackExpression(num, target, i+1, expr+"+"+numStr, eval+numVal, numVal, result)
            
            // Try subtraction
            backtrackExpression(num, target, i+1, expr+"-"+numStr, eval-numVal, -numVal, result)
            
            // Try multiplication (need to undo last operation)
            backtrackExpression(num, target, i+1, expr+"*"+numStr, eval-multed+multed*numVal, multed*numVal, result)
        }
    }
}
```

## Multi-Dimensional Knapsack {#multi-dimensional-knapsack}

### 2D Knapsack (Weight + Volume)

```go
type MultiItem struct {
    Weight int
    Volume int
    Value  int
}

// 2D Knapsack with weight and volume constraints
func knapsack2D(items []MultiItem, maxWeight, maxVolume int) int {
    // dp[w][v] = max value with weight <= w and volume <= v
    dp := make([][]int, maxWeight+1)
    for i := range dp {
        dp[i] = make([]int, maxVolume+1)
    }
    
    for _, item := range items {
        // Process backwards to avoid using same item multiple times
        for w := maxWeight; w >= item.Weight; w-- {
            for v := maxVolume; v >= item.Volume; v-- {
                dp[w][v] = max(dp[w][v], dp[w-item.Weight][v-item.Volume]+item.Value)
            }
        }
    }
    
    return dp[maxWeight][maxVolume]
}

// Multiple knapsacks (distribute items among k knapsacks)
func multipleKnapsacks(items []Item, capacities []int) int {
    k := len(capacities)
    n := len(items)
    
    // Use bitmask DP: dp[mask] = max value when items in mask are used
    maxMask := 1 << n
    dp := make([]int, maxMask)
    
    for mask := 0; mask < maxMask; mask++ {
        // Try assigning remaining items to each knapsack
        for knapsack := 0; knapsack < k; knapsack++ {
            weight := 0
            value := 0
            
            // Calculate current knapsack load
            for i := 0; i < n; i++ {
                if (mask>>i)&1 == 1 {
                    weight += items[i].Weight
                    value += items[i].Value
                }
            }
            
            if weight <= capacities[knapsack] {
                dp[mask] = max(dp[mask], value)
                
                // Try adding more items to this knapsack
                for i := 0; i < n; i++ {
                    if (mask>>i)&1 == 0 && weight+items[i].Weight <= capacities[knapsack] {
                        newMask := mask | (1 << i)
                        dp[newMask] = max(dp[newMask], dp[mask]+items[i].Value)
                    }
                }
            }
        }
    }
    
    return dp[maxMask-1]
}
```

## Optimization Techniques {#optimization-techniques}

### Space Optimization

```go
// 1D space optimization for 0/1 knapsack
func knapsackSpaceOptimized(items []Item, capacity int) int {
    dp := make([]int, capacity+1)
    
    for _, item := range items {
        // Must iterate backwards for 0/1 knapsack
        for w := capacity; w >= item.Weight; w-- {
            dp[w] = max(dp[w], dp[w-item.Weight]+item.Value)
        }
    }
    
    return dp[capacity]
}

// Rolling array for tracking solutions
func knapsackRolling(items []Item, capacity int) (int, []int) {
    n := len(items)
    
    // Use two arrays instead of full 2D array
    prev := make([]int, capacity+1)
    curr := make([]int, capacity+1)
    
    // Track decisions for backtracking
    decisions := make([][]bool, n)
    for i := range decisions {
        decisions[i] = make([]bool, capacity+1)
    }
    
    for i := 0; i < n; i++ {
        for w := 0; w <= capacity; w++ {
            curr[w] = prev[w]  // Don't take item
            
            if items[i].Weight <= w {
                takeValue := prev[w-items[i].Weight] + items[i].Value
                if takeValue > curr[w] {
                    curr[w] = takeValue
                    decisions[i][w] = true
                }
            }
        }
        prev, curr = curr, prev
    }
    
    // Backtrack to find selected items
    selected := []int{}
    w := capacity
    for i := n - 1; i >= 0; i-- {
        if decisions[i][w] {
            selected = append(selected, i)
            w -= items[i].Weight
        }
    }
    
    return prev[capacity], selected
}
```

### Early Termination and Pruning

```go
// Branch and bound optimization
func knapsackBranchBound(items []Item, capacity int) int {
    // Sort items by value/weight ratio (greedy upper bound)
    sort.Slice(items, func(i, j int) bool {
        ratioI := float64(items[i].Value) / float64(items[i].Weight)
        ratioJ := float64(items[j].Value) / float64(items[j].Weight)
        return ratioI > ratioJ
    })
    
    maxValue := 0
    branchBound(items, 0, 0, 0, capacity, &maxValue)
    return maxValue
}

func branchBound(items []Item, idx, currentWeight, currentValue, capacity int, maxValue *int) {
    if idx == len(items) || currentWeight == capacity {
        *maxValue = max(*maxValue, currentValue)
        return
    }
    
    // Calculate upper bound (fractional knapsack for remaining capacity)
    upperBound := currentValue
    remainingCapacity := capacity - currentWeight
    
    for i := idx; i < len(items) && remainingCapacity > 0; i++ {
        if items[i].Weight <= remainingCapacity {
            upperBound += items[i].Value
            remainingCapacity -= items[i].Weight
        } else {
            // Take fraction of this item
            fraction := float64(remainingCapacity) / float64(items[i].Weight)
            upperBound += int(fraction * float64(items[i].Value))
            break
        }
    }
    
    // Prune if upper bound can't improve current best
    if upperBound <= *maxValue {
        return
    }
    
    // Don't take current item
    branchBound(items, idx+1, currentWeight, currentValue, capacity, maxValue)
    
    // Take current item if it fits
    if currentWeight+items[idx].Weight <= capacity {
        branchBound(items, idx+1, currentWeight+items[idx].Weight, 
                   currentValue+items[idx].Value, capacity, maxValue)
    }
}
```

## Real-World Applications {#real-world-applications}

### Resource Allocation System

```go
// Real-world resource allocation with multiple constraints
type Resource struct {
    ID       int
    CPUCost  int
    MemCost  int
    Benefit  int
    Priority int
}

type AllocationSystem struct {
    resources    []Resource
    maxCPU      int
    maxMemory   int
    allocations map[int]bool
}

func NewAllocationSystem(resources []Resource, maxCPU, maxMemory int) *AllocationSystem {
    return &AllocationSystem{
        resources:   resources,
        maxCPU:     maxCPU,
        maxMemory:  maxMemory,
        allocations: make(map[int]bool),
    }
}

func (as *AllocationSystem) OptimalAllocation() (int, []int) {
    n := len(as.resources)
    
    // 3D DP: dp[i][cpu][mem] = max benefit using first i resources
    dp := make([][][]int, n+1)
    for i := range dp {
        dp[i] = make([][]int, as.maxCPU+1)
        for j := range dp[i] {
            dp[i][j] = make([]int, as.maxMemory+1)
        }
    }
    
    // Fill DP table
    for i := 1; i <= n; i++ {
        resource := as.resources[i-1]
        
        for cpu := 0; cpu <= as.maxCPU; cpu++ {
            for mem := 0; mem <= as.maxMemory; mem++ {
                // Don't allocate resource
                dp[i][cpu][mem] = dp[i-1][cpu][mem]
                
                // Allocate resource if constraints satisfied
                if resource.CPUCost <= cpu && resource.MemCost <= mem {
                    benefit := resource.Benefit + resource.Priority // Weighted benefit
                    allocateValue := dp[i-1][cpu-resource.CPUCost][mem-resource.MemCost] + benefit
                    dp[i][cpu][mem] = max(dp[i][cpu][mem], allocateValue)
                }
            }
        }
    }
    
    // Backtrack to find allocated resources
    allocated := []int{}
    cpu, mem := as.maxCPU, as.maxMemory
    
    for i := n; i > 0; i-- {
        resource := as.resources[i-1]
        if cpu >= resource.CPUCost && mem >= resource.MemCost && 
           dp[i][cpu][mem] != dp[i-1][cpu][mem] {
            allocated = append(allocated, resource.ID)
            cpu -= resource.CPUCost
            mem -= resource.MemCost
        }
    }
    
    return dp[n][as.maxCPU][as.maxMemory], allocated
}

// Dynamic resource allocation with changing constraints
func (as *AllocationSystem) RealTimeAllocation(cpuAvailable, memAvailable int) []int {
    // Quick greedy allocation for real-time scenarios
    type resourceRatio struct {
        resource Resource
        ratio    float64
        index    int
    }
    
    ratios := make([]resourceRatio, len(as.resources))
    for i, r := range as.resources {
        // Combined efficiency ratio considering both constraints
        cpuEfficiency := float64(r.Benefit) / float64(r.CPUCost)
        memEfficiency := float64(r.Benefit) / float64(r.MemCost)
        ratios[i] = resourceRatio{
            resource: r,
            ratio:    (cpuEfficiency + memEfficiency) / 2.0,
            index:    i,
        }
    }
    
    // Sort by efficiency ratio
    sort.Slice(ratios, func(i, j int) bool {
        return ratios[i].ratio > ratios[j].ratio
    })
    
    allocated := []int{}
    currentCPU, currentMem := 0, 0
    
    for _, rr := range ratios {
        if currentCPU+rr.resource.CPUCost <= cpuAvailable && 
           currentMem+rr.resource.MemCost <= memAvailable {
            allocated = append(allocated, rr.resource.ID)
            currentCPU += rr.resource.CPUCost
            currentMem += rr.resource.MemCost
        }
    }
    
    return allocated
}
```

### Portfolio Optimization

```go
// Investment portfolio optimization using knapsack
type Investment struct {
    Symbol        string
    Cost          int     // Cost in dollars
    ExpectedReturn float64
    Risk          float64
    Sector        string
}

type PortfolioOptimizer struct {
    investments []Investment
    budget     int
    maxRisk    float64
    sectorLimits map[string]int
}

func NewPortfolioOptimizer(investments []Investment, budget int, maxRisk float64) *PortfolioOptimizer {
    return &PortfolioOptimizer{
        investments: investments,
        budget:     budget,
        maxRisk:    maxRisk,
        sectorLimits: make(map[string]int),
    }
}

func (po *PortfolioOptimizer) OptimizePortfolio() (float64, []string) {
    n := len(po.investments)
    
    // Convert to integer math (multiply returns by 1000)
    maxReturn := 0
    selectedInvestments := []string{}
    
    // Use bit manipulation for subset enumeration
    maxMask := 1 << n
    
    for mask := 0; mask < maxMask; mask++ {
        totalCost := 0
        totalReturn := 0.0
        totalRisk := 0.0
        sectorCount := make(map[string]int)
        portfolio := []string{}
        
        // Calculate portfolio metrics
        for i := 0; i < n; i++ {
            if (mask>>i)&1 == 1 {
                inv := po.investments[i]
                totalCost += inv.Cost
                totalReturn += inv.ExpectedReturn
                totalRisk += inv.Risk
                sectorCount[inv.Sector]++
                portfolio = append(portfolio, inv.Symbol)
            }
        }
        
        // Check constraints
        if totalCost <= po.budget && totalRisk <= po.maxRisk {
            // Check sector diversification
            valid := true
            for sector, count := range sectorCount {
                if limit, exists := po.sectorLimits[sector]; exists && count > limit {
                    valid = false
                    break
                }
            }
            
            if valid && int(totalReturn*1000) > maxReturn {
                maxReturn = int(totalReturn * 1000)
                selectedInvestments = portfolio
            }
        }
    }
    
    return float64(maxReturn) / 1000.0, selectedInvestments
}
```

## Problem Recognition {#problem-recognition}

### Knapsack Pattern Identifier

```go
type KnapsackIdentifier struct {
    patterns map[string][]string
}

func NewKnapsackIdentifier() *KnapsackIdentifier {
    return &KnapsackIdentifier{
        patterns: map[string][]string{
            "01_knapsack": {
                "each item once", "0/1 choice", "bounded items",
                "maximize value", "weight constraint", "capacity limit",
            },
            "unbounded_knapsack": {
                "unlimited items", "infinite use", "coin change",
                "minimum coins", "perfect squares", "ways to make",
            },
            "subset_sum": {
                "subset", "target sum", "partition", "equal sum",
                "can achieve", "possible sum", "divide into groups",
            },
            "target_sum": {
                "assign signs", "+/- operators", "expression target",
                "reach target", "arithmetic operations",
            },
            "multi_knapsack": {
                "multiple constraints", "2D knapsack", "volume and weight",
                "multiple knapsacks", "resource allocation",
            },
        },
    }
}

func (ki *KnapsackIdentifier) IdentifyPattern(problemDescription string) string {
    desc := strings.ToLower(problemDescription)
    
    maxScore := 0
    bestPattern := "unknown"
    
    for pattern, keywords := range ki.patterns {
        score := 0
        for _, keyword := range keywords {
            if strings.Contains(desc, keyword) {
                score++
            }
        }
        
        if score > maxScore {
            maxScore = score
            bestPattern = pattern
        }
    }
    
    return bestPattern
}
```

### Selection Guide

| Pattern Type | Key Indicators | DP Relation | Space Complexity |
|-------------|---------------|-------------|------------------|
| **0/1 Knapsack** | "each item once", "bounded" | `dp[i][w] = max(skip, take)` | O(nW) ‚Üí O(W) |
| **Unbounded** | "unlimited use", "coin change" | `dp[w] = max over all items` | O(W) |
| **Subset Sum** | "target sum", "partition" | `dp[sum] = dp[sum] «Å dp[sum-num]` | O(target) |
| **Multi-Constraint** | "weight + volume", "2D limit" | `dp[w][v] = max(skip, take)` | O(W√óV) |

## Conclusion

The knapsack family of problems provides a powerful framework for solving resource allocation and optimization challenges. These patterns appear across diverse domains from computer science to operations research.

### Knapsack Mastery Framework:

**üéØ Pattern Recognition**
- **0/1 vs Unbounded**: Can items be reused?
- **Optimization vs Counting**: Maximize/minimize vs count ways?
- **Single vs Multiple constraints**: Weight only vs weight+volume+other?

**üîß Implementation Strategy**
- **State Design**: What dimensions capture the problem?
- **Transition Logic**: How do decisions affect the state?
- **Space Optimization**: Can we reduce from 2D to 1D?

**‚ö° Performance Optimization**
- **Early Termination**: Branch and bound techniques
- **Constraint Propagation**: Use problem structure for pruning
- **Approximation**: When exact solution is too expensive

### Key Takeaways:

1. **Knapsack problems model resource allocation** under constraints
2. **0/1 vs unbounded** determines iteration direction (backwards vs forwards)
3. **Space optimization** is often possible using rolling arrays
4. **Multi-constraint problems** extend to higher dimensions
5. **Real-world applications** require handling multiple objectives and constraints

**üöÄ Next Steps**: With knapsack patterns mastered, you're ready to explore sequence-based DP problems like LIS, LCS, and edit distance!

---

*Next in series: [DP Sequence Patterns](/blog/dsa/dp-sequence-patterns) | Previous: [DP Basic Patterns](/blog/dsa/dp-basic-patterns)*